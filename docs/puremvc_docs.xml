<haxe>
	<class path="neko.Lib" params="" file="/usr/lib/haxe/std/neko/Lib.hx">
		<load public="1" set="method" line="29" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>Load and return a Neko primitive from a NDLL library.</haxe_doc>
		</load>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="Array" params="T" file="/usr/lib/haxe/std/neko/_std/Array.hx">
		<new1 params="T" set="method" line="32" static="1"><f a="a:l">
	<c path="neko.NativeArray"><c path="new1.T"/></c>
	<x path="Int"/>
	<c path="Array"><c path="new1.T"/></c>
</f></new1>
		<__neko set="method" line="290"><f a=""><c path="neko.NativeArray"><c path="Array.T"/></c></f></__neko>
		<__double set="method" line="275"><f a="l">
	<x path="Int"/>
	<x path="Void"/>
</f></__double>
		<__set set="method" line="260"><f a="pos:v">
	<x path="Int"/>
	<c path="Array.T"/>
	<c path="Array.T"/>
</f></__set>
		<__get set="method" line="256"><f a="pos">
	<x path="Int"/>
	<c path="Array.T"/>
</f></__get>
		<filter public="1" set="method" line="245"><f a="f">
	<f a="">
		<c path="Array.T"/>
		<x path="Bool"/>
	</f>
	<c path="Array"><c path="Array.T"/></c>
</f></filter>
		<map public="1" params="S" set="method" line="238"><f a="f">
	<f a="">
		<c path="Array.T"/>
		<c path="map.S"/>
	</f>
	<c path="Array"><c path="map.S"/></c>
</f></map>
		<splice public="1" set="method" line="215">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes [len] elements from [this] Array, starting at and including
		[pos], an returns them.
		
		This operation modifies [this] Array in place.
		
		If [len] is < 0 or [pos] exceeds [this].length, the result is the empty
		Array [].
		
		If [pos] is negative, its value is calculated from the end	of [this]
		Array by [this].length + [pos]. If this yields a negative value, 0 is
		used instead.
		
		If the sum of the resulting values for [len] and [pos] exceed
		[this].length, this operation will affect the elements from [pos] to the
		end of [this] Array.
		
		The length of the returned Array is equal to the new length of [this]
		Array subtracted from the original length of [this] Array. In other
		words, each element of the original [this] Array either remains in
		[this] Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<sort public="1" set="method" line="192">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts [this] Array according to the comparison function [f], where
		[f(x,y)] returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.
		
		This operation modifies [this] Array in place.
		
		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, haxe.ds.sort.MergeSort.sort() can be used instead.
		
		If [f] is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<slice public="1" set="method" line="175">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of [this] Array, starting at and
		including [pos], up to but not including [end].
		
		This operation does not modify [this] Array.
		
		The elements are not copied and retain their identity.
		
		If [end] is omitted or exceeds [this].length, it defaults to the end of
		[this] Array.
		
		If [pos] or [end] are negative, their offsets are calculated from the
		end	of [this] Array by [this].length + [pos] and [this].length + [end]
		respectively. If this yields a negative value, 0 is used instead.
		
		If [pos] exceeds [this].length or if [end} exceeds or equals [pos],
		the result is [].</haxe_doc>
		</slice>
		<shift public="1" set="method" line="162">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element of [this] Array and returns it.
		
		This operation modifies [this] Array in place.
		
		If [this] has at least one element, [this].length and the index of each
		remaining element is decreased by 1.
		
		If [this] is the empty Array [], null is returned and the length remains
		0.</haxe_doc>
		</shift>
		<reverse public="1" set="method" line="148">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of [this] Array.
		
		This operation modifies [this] Array in place.
		
		If [this].length < 2, [this] remains unchanged.]]></haxe_doc>
		</reverse>
		<remove public="1" set="method" line="131">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of [x] in [this] Array.
		
		This operation modifies [this] Array in place.
		
		If [x] is found by checking standard equality, it is removed from [this]
		Array and all following elements are reindexed acoordingly. The function
		then returns true.
		
		If [x] is not found, [this] Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<unshift public="1" set="method" line="123">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element [x] at the start of [this] Array.
		
		This operation modifies [this] Array in place.
		
		[this].length and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<push public="1" set="method" line="116">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element [x] at the end of [this] Array and returns the offset
		it was added at.
		
		This operation modifies [this] Array in place.
		
		[this].length will increase by 1.</haxe_doc>
		</push>
		<pop public="1" set="method" line="107">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of [this] Array and returns it.
		
		This operation modifies [this] Array in place.
		
		If [this] has at least one element, [this].length will decrease by 1.
		
		If [this] is the empty Array [], null is returned and the length remains
		0.</haxe_doc>
		</pop>
		<toString public="1" set="method" line="94">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of [this] Array.
		
		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use Std.string() to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<join public="1" set="method" line="82">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of [this] Array, with [sep] separating
		each element.
		
		The result of this operation is equal to Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1]).
		
		If [this] is the empty Array [], the result is the empty String "". If
		[this] has exactly one element, the result is equal to a call to
		Std.string(this[0]).
		
		If [a] is null, the result is unspecified.</haxe_doc>
		</join>
		<insert public="1" set="method" line="69">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element [x] at the position [pos].
		
		This operation modifies [this] Array in place.
		
		The offset is calculated like so:
			
		- If [pos] exceeds [this].length, the offset is [this].length.
		- If [pos] is negative, the offset is calculated from the end of [this]
		Array, i.e. [this].length + [pos]. If this yields a negative value,
		the offset is 0.
		- Otherwise, the offset is [pos].
		
		If the resulting offset does not exceed [this].length, all elements from
		and including that offset to the end of [this] Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<iterator public="1" set="method" line="54">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<copy public="1" set="method" line="50">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of [this] Array.
		
		The elements are not copied and retain their identity, so
		a[i] == a.copy()[i] is true for any valid i. However, a == a.copy() is
		always false.</haxe_doc>
		</copy>
		<concat public="1" set="method" line="39">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of [a] to the elements of
		[this] Array.
		
		This operation does not modify [this] Array.
		
		If [a] is the empty Array [], a copy of [this] Array is returned.
		
		The length of the returned Array is equal to the sum of [this].length
		and [a].length.
		
		If [a] is null, the result is unspecified.</haxe_doc>
		</concat>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of [this] Array.</haxe_doc>
		</length>
		<__a><c path="neko.NativeArray"><c path="Array.T"/></c></__a>
		<new public="1" set="method" line="27">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.</haxe_doc>
		<meta>
			<m n=":coreApi"/>
			<m n=":final"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="/usr/lib/haxe/std/Class.hx">
		<haxe_doc>An abstract type that represents a Class.
	
	See [Type] for the haXe Reflection API.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx">
		<haxe_doc>An abstract type that represents an Enum type.
	
	The corresponding enum instance type is EnumValue.
	
	See [Type] for the haXe Reflection API.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx">
		<haxe_doc>An abstract type that represents any enum value.
	See [Type] for the haXe Reflection API.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="List" params="T" file="/usr/lib/haxe/std/List.hx">
		<iterator public="1" set="method" line="148"><f a=""><t path="Iterator"><c path="List.T"/></t></f></iterator>
		<remove public="1" set="method" line="125"><f a="v">
	<c path="List.T"/>
	<x path="Bool"/>
</f></remove>
		<isEmpty public="1" set="method" line="108"><f a=""><x path="Bool"/></f></isEmpty>
		<pop public="1" set="method" line="94"><f a=""><t path="Null"><c path="List.T"/></t></f></pop>
		<add public="1" set="method" line="47"><f a="item">
	<c path="List.T"/>
	<x path="Void"/>
</f></add>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of elements in this list.</haxe_doc>
		</length>
		<q><c path="Array"><d/></c></q>
		<h><c path="Array"><d/></c></h>
		<new public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<to><x path="Float"/></to>
		<haxe_doc>The standard Int type. Its precision depends on the platform.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<haxe_doc>The standard Float type, this is a double-precision IEEE 64bit float.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<haxe_doc>The standard Boolean type is represented as an enum with two choices.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<haxe_doc>Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="neko.Boot" params="" file="/usr/lib/haxe/std/neko/Boot.hx">
		<__tmp_str set="method" line="27" static="1"><f a=""><c path="String"/></f></__tmp_str>
		<__enum_str set="method" line="31" static="1"><f a="e">
	<d/>
	<c path="String"/>
</f></__enum_str>
		<__interfLoop set="method" line="53" static="1"><f a="cc:cl">
	<d/>
	<d/>
	<x path="Bool"/>
</f></__interfLoop>
		<__instanceof set="method" line="69" static="1">
			<f a="o:cl">
				<a>
					<__name__ set="null"><unknown/></__name__>
					<__enum__ set="null"><t path="#Dynamic"/></__enum__>
					<__ename__ set="null"><unknown/></__ename__>
					<__class__ set="null"><unknown/></__class__>
				</a>
				<t path="#Dynamic"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":ifFeature"><e>"typed_catch"</e></m></meta>
		</__instanceof>
		<__serialize set="method" line="87" static="1"><f a="o">
	<a>
		<__enum__ set="null"><a><__ename__ set="null"><a><length set="null"><x path="Int"/></length></a></__ename__></a></__enum__>
		<__class__ set="null"><a><__name__ set="null"><a><length set="null"><x path="Int"/></length></a></__name__></a></__class__>
	</a>
	<c path="Array"><unknown/></c>
</f></__serialize>
		<__tagserialize set="method" line="107" static="1"><f a="o">
	<a>
		<tag set="null"><unknown/></tag>
		<__enum__ set="null"><a><__ename__ set="null"><a><length set="null"><x path="Int"/></length></a></__ename__></a></__enum__>
	</a>
	<c path="Array"><unknown/></c>
</f></__tagserialize>
		<__unserialize set="method" line="116" static="1"><f a="v">
	<c path="Array"><unknown/></c>
	<unknown/>
</f></__unserialize>
		<__init set="method" line="139" static="1"><f a=""><x path="Void"/></f></__init>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/neko/_std/Std.hx">
		<string public="1" set="method" line="29" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If s is of String, Int, Float or Bool, its value is returned.

		If s is an instance of a class and that class or one of its parent classes has
		a toString() method, that method is called. If no such method is present, the result
		is unspecified.

		If s is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If s is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<haxe_doc>The standard Void type. Only [null] values can be of the type [Void].</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the Iterator and advances to the next one.
		
		This method is not required to check hasNext() first. A call to this
		method while hasNext() is false yields unspecified behavior.</haxe_doc>
			</next>
			<hasNext set="method"><f a=""><x path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits iteration over elements of type T.

	Any class with matching hasNext and next fields is considered an Iterator
	and can then be used e.g. in for-loops. This makes it easy to implement
	custom iterators.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="/usr/lib/haxe/std/neko/_std/String.hx">
		<__is_String static="1"><x path="Bool"/></__is_String>
		<__split line="25" static="1"><d/></__split>
		<fromCharCode public="1" set="method" line="200" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code [code].
		
		If [code] is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<__radd set="method" line="196"><f a="s">
	<d/>
	<c path="String"/>
</f></__radd>
		<__add set="method" line="192"><f a="s">
	<d/>
	<c path="String"/>
</f></__add>
		<__compare set="method" line="188"><f a="o">
	<c path="String"/>
	<x path="Int"/>
</f></__compare>
		<toString public="1" set="method" line="182">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<toUpperCase public="1" set="method" line="166">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of [this] String are upper case.
		
		Affects the characters [a-z]. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method" line="150">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of [this] String are lower case.
		
		Affects the characters [A-Z]. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<substring public="1" set="method" line="126">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of [this] String from [startIndex] to [endIndex].
		
		If [endIndex] is omitted, [this].length is used instead.
		
		If [startIndex] or [endIndex] are negative, 0 is used instead.
		
		If [startIndex] exceeds [endIndex], they are swapped.</haxe_doc>
		</substring>
		<substr public="1" set="method" line="100">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns [len] characters of [this] String, starting at position [pos].
		
		If [len] is omitted, all characters from position [pos] to the end of
		[this] String are included.
		
		If [pos] is negative, its values is calculated from the end	of [this]
		String by [this].length + [pos]. If this yields a negative value, 0 is
		used instead.
		
		If [len] is negative, the result is unspecified.</haxe_doc>
		</substr>
		<split public="1" set="method" line="84">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits [this] String at each occurence of [delimiter].
		
		If [delimiter] is the empty String "", [this] String is split into an
		Array of [this].length elements, where the elements correspond to the
		characters of [this] String.
		
		If [delimiter] is not found within [this] String, the result is an Array
		with one element, which equals [this] String.
		
		If [delimiter] is null, the result is unspecified.
		
		Otherwise, [this] String is split into parts at each occurence of
		[delimiter]. If [this] String starts (or ends) with [delimiter}, the
		result Array contains a leading (or trailing) empty String "" element.
		Two subsequent delimiters also result in an empty String "" element.</haxe_doc>
		</split>
		<lastIndexOf public="1" set="method" line="69">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of [str] within [this]
		String.
		
		If [startIndex] is given, the search is performed within the substring
		of [this] String from 0 to [startIndex]. Otherwise the search is
		performed within [this] String. In either case, the returned position
		is relative to the beginning of [this] String.
		
		If [str] cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<indexOf public="1" set="method" line="60">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurence of [str] within [this]
		String.
		
		If [startIndex] is given, the search is performed within the substring
		of [this] String starting from [startIndex]. Otherwise the search is
		performed within [this] String. In either case, the returned position
		is relative to the beginning of [this] String.
		
		If [str] cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<charCodeAt public="1" set="method" line="54">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at position [index] of [this] String.
		
		If [index] is negative or exceeds [this].length, null is returned.
		
		To obtain the character code of a single character, "x".code can be used
		instead to inline the character code at compile time. Note that this
		only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<charAt public="1" set="method" line="42">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position [index] of [this] String.
		
		If [index] is negative or exceeds [this].length, the empty String ""
		is returned.</haxe_doc>
		</charAt>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in [this] String.</haxe_doc>
		</length>
		<new public="1" set="method" line="33">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.
	
	A haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of [this] String.
	
	Strings can be constructed using the string literal syntax "string value".
	
	String can be concatenated by using the + operator. If an operand is not a
	String, it is passed through Std.string() first.</haxe_doc>
		<meta>
			<m n=":coreApi"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/neko/_std/StringBuf.hx">
		<__make line="46" static="1"><d/></__make>
		<__add line="47" static="1"><d/></__add>
		<__add_char line="48" static="1"><d/></__add_char>
		<__to_string line="50" static="1"><d/></__to_string>
		<b><d/></b>
		<new public="1" set="method" line="26">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.
		
		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.
	
	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.
	
	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Type" params="" file="/usr/lib/haxe/std/neko/_std/Type.hx">
		<createInstance public="1" params="T" set="method" line="98" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class [cl], using [args] as arguments to the
		class constructor.
		
		This function guarantees that the class constructor is called.
		
		Default values of constructors arguments are not guaranteed to be
		taken into account.
		
		If [cl] or [args] are null, or if the number of elements in [args] does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if [cl] has no own constructor, the
		result is unspecified.
		
		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<haxe_doc>The haxe Reflection API allows retrieval of type information at runtime.
	
	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.EnumTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="41" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum [e], including its path.
		
		If [e] is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If [e] is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If [e] has no package, the enum name is returned.
		
		If [e] is null, the result is unspecified.
		
		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="54" static="1"><f a="e:constr:?params">
	<x path="Enum"><c path="createByName.T"/></x>
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="createByName.T"/>
</f></createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="70" static="1"><f a="e:index:?params">
	<x path="Enum"><c path="createByIndex.T"/></x>
	<x path="Int"/>
	<c path="Array"><d/></c>
	<c path="createByIndex.T"/>
</f></createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="87" static="1"><f a="e">
	<x path="Enum"><c path="createAll.T"/></x>
	<c path="Array"><c path="createAll.T"/></c>
</f></createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="99" static="1"><f a="e">
	<x path="Enum"><c path="getConstructors.T"/></x>
	<c path="Array"><c path="String"/></c>
</f></getConstructors>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="114" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances [a] and [b] by value.
		
		Unlike [a] == [b], this function performs a deep equality check on the
		arguments of the constructors, if exists.
		
		If [a] or [b] are null, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="125" static="1"><f a="e">
	<x path="EnumValue"/>
	<c path="String"/>
</f></getName>
		<getParameters public="1" get="inline" set="null" line="139" static="1"><f a="e">
	<x path="EnumValue"/>
	<c path="Array"><d/></c>
</f></getParameters>
		<getIndex public="1" get="inline" set="null" line="151" static="1"><f a="e">
	<x path="EnumValue"/>
	<x path="Int"/>
</f></getIndex>
	</class>
	<class path="haxe.ds.StringMap" params="T" file="/usr/lib/haxe/std/neko/_std/haxe/ds/StringMap.hx">
		<h><d/></h>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx"><c path="neko.NativeString"/></typedef>
	<class path="neko.NativeArray" params="T" file="/usr/lib/haxe/std/neko/NativeArray.hx"><meta><m n=":keep"/></meta></class>
	<class path="org.puremvc.haxe.multicore.interfaces.IController" params="" file="src/org/puremvc/haxe/multicore/interfaces/IController.hx" interface="1">
		<removeController public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove an IController instance</haxe_doc>
		</removeController>
		<hasCommand public="1" set="method">
			<f a="notificationName">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if a Command is registered for a given Notification</haxe_doc>
		</hasCommand>
		<removeCommand public="1" set="method">
			<f a="notificationName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove a previously registered [ICommand] to [INotification] mapping.</haxe_doc>
		</removeCommand>
		<executeCommand public="1" set="method">
			<f a="notification">
				<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Execute the [ICommand] previously registered as the
	 * handler for [INotification]s with the given notification name.</haxe_doc>
		</executeCommand>
		<registerCommand public="1" set="method">
			<f a="notificationName:commandClassRef">
				<c path="String"/>
				<x path="Class"><c path="org.puremvc.haxe.multicore.interfaces.ICommand"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a particular [ICommand] class as the handler 
	 * for a particular [INotification].</haxe_doc>
		</registerCommand>
		<haxe_doc><![CDATA[* The interface definition for a PureMVC Controller.
 * 
 * <p>In PureMVC, an [IController] implementor 
 * follows the 'Command and Controller' strategy, and 
 * assumes these responsibilities:</p>
 * <ul>
 * <li> Remembering which [ICommand]s 
 * are intended to handle which [INotifications].</li>
 * <li> Registering itself as an [IObserver] with
 * the [View] for each [INotification] 
 * that it has an [ICommand] mapping for.</li>
 * <li> Creating a new instance of the proper [ICommand]
 * to handle a given [INotification] when notified by the [View].</li>
 * <li> Calling the [ICommand]'s [execute]
 * method, passing in the [INotification].</li>
 * </ul>]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.core.Controller" params="" file="src/org/puremvc/haxe/multicore/core/Controller.hx">
		<implements path="org.puremvc.haxe.multicore.interfaces.IController"/>
		<getInstance public="1" set="method" line="75" static="1"><f a="key">
	<c path="String"/>
	<c path="org.puremvc.haxe.multicore.interfaces.IController"/>
</f></getInstance>
		<instanceMap static="1"><c path="haxe.ds.StringMap"><c path="org.puremvc.haxe.multicore.interfaces.IController"/></c></instanceMap>
		<multitonKey><c path="String"/></multitonKey>
		<commandMap><c path="haxe.ds.StringMap"><x path="Class"><c path="org.puremvc.haxe.multicore.interfaces.ICommand"/></x></c></commandMap>
		<view><c path="org.puremvc.haxe.multicore.interfaces.IView"/></view>
		<removeController public="1" set="method" line="139"><f a="key">
	<c path="String"/>
	<x path="Void"/>
</f></removeController>
		<removeCommand public="1" set="method" line="124"><f a="notificationName">
	<c path="String"/>
	<x path="Void"/>
</f></removeCommand>
		<hasCommand public="1" set="method" line="116"><f a="notificationName">
	<c path="String"/>
	<x path="Bool"/>
</f></hasCommand>
		<registerCommand public="1" set="method" line="106"><f a="notificationName:commandClassRef">
	<c path="String"/>
	<x path="Class"><c path="org.puremvc.haxe.multicore.interfaces.ICommand"/></x>
	<x path="Void"/>
</f></registerCommand>
		<executeCommand public="1" set="method" line="86"><f a="note">
	<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
	<x path="Void"/>
</f></executeCommand>
		<initializeController set="method" line="67"><f a=""><x path="Void"/></f></initializeController>
		<new set="method" line="50">
			<f a="key">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Constructor. 
	 * 
	 * <p>This [IController] implementation is a Multiton, so you cannot
	 * call the constructor directly, but instead call the static 
	 * Factory method passing the unique key for this instance
	 * [Controller.getInstance( multitonKey )]</p>]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A Multiton [IController] implementation.
 * 
 * <p>In PureMVC, the [Controller] class follows the
 * 'Command and Controller' strategy, and assumes these responsibilities:</p>
 * <ul>
 * <li> Remembering which [ICommand]s are intended to handle which [INotifications].</li>
 * <li> Registering itself as an [IObserver] with the [View] for each [INotification] 
 * that it has an [ICommand] mapping for.</li>
 * <li> Creating a new instance of the proper [ICommand] to handle a given [INotification]
 * when notified by the [View].</li>
 * <li> Calling the [ICommand]'s [execute] method, passing in the [INotification].</li> 
 * </ul>
 * 
 * <p>Your application must register [ICommands] with the Controller.
 * The simplest way is to subclass [Facade], 
 * and use its [initializeController] method to add your registrations.</p>]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.interfaces.IModel" params="" file="src/org/puremvc/haxe/multicore/interfaces/IModel.hx" interface="1">
		<removeModel public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove an IModel instance</haxe_doc>
		</removeModel>
		<hasProxy public="1" set="method">
			<f a="proxyName">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if a [Proxy] is registered</haxe_doc>
		</hasProxy>
		<removeProxy public="1" set="method">
			<f a="proxyName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
			</f>
			<haxe_doc>* Remove an [IProxy] instance from the Model.</haxe_doc>
		</removeProxy>
		<retrieveProxy public="1" set="method">
			<f a="proxyName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
			</f>
			<haxe_doc>* Retrieve an [IProxy] instance from the Model.</haxe_doc>
		</retrieveProxy>
		<registerProxy public="1" set="method">
			<f a="proxy">
				<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register an [IProxy] instance with the [Model].</haxe_doc>
		</registerProxy>
		<haxe_doc><![CDATA[* The interface definition for a PureMVC Model.
 * 
 * <p>In PureMVC, [IModel] implementors provide
 * access to [IProxy] objects by named lookup. </p>
 * 
 * <p>An [IModel] assumes these responsibilities:</p>
 * <ul>
 * <li>Maintain a cache of [IProxy] instances</li>
 * <li>Provide methods for registering, retrieving, and removing [IProxy] instances</li>
 * </ul>]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.core.Model" params="" file="src/org/puremvc/haxe/multicore/core/Model.hx">
		<implements path="org.puremvc.haxe.multicore.interfaces.IModel"/>
		<getInstance public="1" set="method" line="63" static="1"><f a="key">
	<c path="String"/>
	<c path="org.puremvc.haxe.multicore.interfaces.IModel"/>
</f></getInstance>
		<instanceMap static="1"><c path="haxe.ds.StringMap"><c path="org.puremvc.haxe.multicore.interfaces.IModel"/></c></instanceMap>
		<multitonKey><c path="String"/></multitonKey>
		<proxyMap><c path="haxe.ds.StringMap"><c path="org.puremvc.haxe.multicore.interfaces.IProxy"/></c></proxyMap>
		<removeModel public="1" set="method" line="113"><f a="key">
	<c path="String"/>
	<x path="Void"/>
</f></removeModel>
		<removeProxy public="1" set="method" line="99"><f a="proxyName">
	<c path="String"/>
	<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
</f></removeProxy>
		<hasProxy public="1" set="method" line="91"><f a="proxyName">
	<c path="String"/>
	<x path="Bool"/>
</f></hasProxy>
		<retrieveProxy public="1" set="method" line="83"><f a="proxyName">
	<c path="String"/>
	<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
</f></retrieveProxy>
		<registerProxy public="1" set="method" line="73"><f a="proxy">
	<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
	<x path="Void"/>
</f></registerProxy>
		<initializeModel set="method" line="56"><f a=""><x path="Void"/></f></initializeModel>
		<new set="method" line="42">
			<f a="key">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Constructor. 
	 * 
	 * <p>This [IModel] implementation is a Multiton,
	 * so you should not call the constructor 
	 * directly, but instead call the static Multiton
	 * Factory method [Model.getInstance( multitonKey )]</p>]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A Singleton [IModel] implementation.
 * 
 * <p>In PureMVC, the [Model] class provides access to model objects (Proxies) by named lookup.</p> 
 * 
 * <p>The [Model] assumes these responsibilities:</p>
 * <ul>
 * <li>Maintain a cache of [IProxy] instances.</li>
 * <li>Provide methods for registering, retrieving, and removing [IProxy] instances.</li>
 * </ul>
 * 
 * <p>Your application must register [IProxy] instances with the [Model]. Typically, you use an 
 * [ICommand] to create and register [IProxy] instances once the [Facade] has initialized the Core 
 * actors.</p>]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.interfaces.IView" params="" file="src/org/puremvc/haxe/multicore/interfaces/IView.hx" interface="1">
		<removeView public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove an IView instance</haxe_doc>
		</removeView>
		<hasMediator public="1" set="method">
			<f a="mediatorName">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if a [Mediator] is registered or not</haxe_doc>
		</hasMediator>
		<removeMediator public="1" set="method">
			<f a="mediatorName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
			</f>
			<haxe_doc>* Remove an [IMediator] from the [View].</haxe_doc>
		</removeMediator>
		<retrieveMediator public="1" set="method">
			<f a="mediatorName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
			</f>
			<haxe_doc>* Retrieve an [IMediator] from the [View].</haxe_doc>
		</retrieveMediator>
		<registerMediator public="1" set="method">
			<f a="mediator">
				<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Register an [IMediator] instance with the [View].
	 * 
	 * <p>Registers the [IMediator] so that it can be retrieved by name,
	 * and further interrogates the [IMediator] for its [INotification] interests.</p>
	 *
	 * <p>If the [IMediator] returns any [INotification] 
	 * names to be notified about, an [Observer] is created encapsulating 
	 * the [IMediator] instance's [handleNotification] method 
	 * and registering it as an [Observer] for all [INotifications] the 
	 * [IMediator] is interested in.</p>]]></haxe_doc>
		</registerMediator>
		<notifyObservers public="1" set="method">
			<f a="note">
				<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Notify the [IObservers] for a particular [INotification].
	 * 
	 * <p>All previously attached [IObservers] for this [INotification]'s
	 * list are notified and are passed a reference to the [INotification] in 
	 * the order in which they were registered.</p>]]></haxe_doc>
		</notifyObservers>
		<removeObserver public="1" set="method">
			<f a="notificationName:notifyContext">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove a group of observers from the observer list for a given Notification name.</haxe_doc>
		</removeObserver>
		<registerObserver public="1" set="method">
			<f a="noteName:observer">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IObserver"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register an [IObserver] to be notified of [INotifications] with a given name.</haxe_doc>
		</registerObserver>
		<haxe_doc><![CDATA[* The interface definition for a PureMVC View.
 * 
 * <p>In PureMVC, the [View] class assumes these responsibilities:
 * <ul>
 * <li>Maintain a cache of [IMediator] instances.</li>
 * <li>Provide methods for registering, retrieving, and removing [IMediators].</li>
 * <li>Managing the observer lists for each [INotification] in the application.</li>
 * <li>Providing a method for attaching [IObservers] to an [INotification]'s observer list.</li>
 * <li>Providing a method for broadcasting an [INotification].</li>
 * <li>Notifying the [IObservers] of a given [INotification] when it broadcast.</li>
 * </ul>]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.core.View" params="" file="src/org/puremvc/haxe/multicore/core/View.hx">
		<implements path="org.puremvc.haxe.multicore.interfaces.IView"/>
		<getInstance public="1" set="method" line="68" static="1"><f a="key">
	<c path="String"/>
	<c path="org.puremvc.haxe.multicore.interfaces.IView"/>
</f></getInstance>
		<instanceMap static="1"><c path="haxe.ds.StringMap"><c path="org.puremvc.haxe.multicore.interfaces.IView"/></c></instanceMap>
		<multitonKey><c path="String"/></multitonKey>
		<observerMap><c path="haxe.ds.StringMap"><c path="List"><c path="org.puremvc.haxe.multicore.interfaces.IObserver"/></c></c></observerMap>
		<mediatorMap><c path="haxe.ds.StringMap"><c path="org.puremvc.haxe.multicore.interfaces.IMediator"/></c></mediatorMap>
		<removeView public="1" set="method" line="212"><f a="key">
	<c path="String"/>
	<x path="Void"/>
</f></removeView>
		<hasMediator public="1" set="method" line="204"><f a="mediatorName">
	<c path="String"/>
	<x path="Bool"/>
</f></hasMediator>
		<removeMediator public="1" set="method" line="175"><f a="mediatorName">
	<c path="String"/>
	<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
</f></removeMediator>
		<retrieveMediator public="1" set="method" line="167"><f a="mediatorName">
	<c path="String"/>
	<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
</f></retrieveMediator>
		<registerMediator public="1" set="method" line="142"><f a="mediator">
	<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
	<x path="Void"/>
</f></registerMediator>
		<removeObserver public="1" set="method" line="105"><f a="notificationName:notifyContext">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></removeObserver>
		<notifyObservers public="1" set="method" line="92"><f a="notification">
	<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
	<x path="Void"/>
</f></notifyObservers>
		<registerObserver public="1" set="method" line="78"><f a="notificationName:observer">
	<c path="String"/>
	<c path="org.puremvc.haxe.multicore.interfaces.IObserver"/>
	<x path="Void"/>
</f></registerObserver>
		<initializeView set="method" line="61"><f a=""><x path="Void"/></f></initializeView>
		<new public="1" set="method" line="46">
			<f a="key">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Constructor. 
	 * 
	 * <p>This [IView] implementation is a Multiton, 
	 * so you should not call the constructor 
	 * directly, but instead call the static Multiton 
	 * Factory method [View.getInstance( multitonKey )]</p>]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A Multiton [IView] implementation.
 * 
 * <p>In PureMVC, the [View] class assumes these responsibilities:</p>
 * <ul>
 * <li>Maintain a cache of [IMediator] instances.</li>
 * <li>Provide methods for registering, retrieving, and removing [IMediators].</li>
 * <li>Notifiying [IMediators] when they are registered or removed.</li>
 * <li>Managing the observer lists for each [INotification] in the application.</li>
 * <li>Providing a method for attaching [IObservers] to an [INotification]'s observer list.</li>
 * <li>Providing a method for broadcasting an [INotification].</li>
 * <li>Notifying the [IObservers] of a given [INotification] when it broadcast.</li>
 * </ul>]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.interfaces.INotifier" params="" file="src/org/puremvc/haxe/multicore/interfaces/INotifier.hx" interface="1">
		<initializeNotifier public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Initialize this INotifier instance.
	 * 
	 * <p>This is how a Notifier gets its multitonKey. 
	 * Calls to sendNotification or to access the
	 * facade will fail until after this method 
	 * has been called.</p>]]></haxe_doc>
		</initializeNotifier>
		<sendNotification public="1" set="method">
			<f a="notificationName:?body:?type">
				<c path="String"/>
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Send a [INotification].
	 * 
	 * <p>Convenience method to prevent having to construct new 
	 * notification instances in our implementation code.</p>]]></haxe_doc>
		</sendNotification>
		<haxe_doc><![CDATA[* The interface definition for a PureMVC Notifier.
 * 
 * <p>[MacroCommand, Command, Mediator] and [Proxy]
 * all have a need to send [Notifications]. </p>
 * 
 * <p>The [INotifier] interface provides a common method called
 * [sendNotification] that relieves implementation code of 
 * the necessity to actually construct [Notifications].</p>
 * 
 * <p>The [Notifier] class, which all of the above mentioned classes
 * extend, also provides an initialized reference to the [Facade]
 * Singleton, which is required for the convienience method
 * for sending [Notifications], but also eases implementation as these
 * classes have frequent [Facade] interactions and usually require
 * access to the facade anyway.</p>]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.interfaces.ICommand" params="" file="src/org/puremvc/haxe/multicore/interfaces/ICommand.hx" interface="1">
		<extends path="org.puremvc.haxe.multicore.interfaces.INotifier"/>
		<execute public="1" set="method">
			<f a="notification">
				<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Execute the [ICommand]'s logic to handle a given [INotification].</haxe_doc>
		</execute>
		<haxe_doc>* The interface definition for a PureMVC Command.</haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.interfaces.IFacade" params="" file="src/org/puremvc/haxe/multicore/interfaces/IFacade.hx" interface="1">
		<extends path="org.puremvc.haxe.multicore.interfaces.INotifier"/>
		<removeCore public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove a Core</haxe_doc>
		</removeCore>
		<notifyObservers public="1" set="method">
			<f a="note">
				<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Notify the [IObservers] for a particular [INotification].
	 * 
	 * <p>All previously attached [IObservers] for this [INotification]'s
	 * list are notified and are passed a reference to the [INotification] in 
	 * the order in which they were registered.</p>
	 * 
	 * <p>NOTE: Use this method only if you are sending custom Notifications. Otherwise
	 * use the sendNotification method which does not require you to create the
	 * Notification instance.</p>]]></haxe_doc>
		</notifyObservers>
		<sendNotification public="1" set="method">
			<f a="notificationName:?body:?type">
				<c path="String"/>
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create and send an [INotification].</haxe_doc>
		</sendNotification>
		<hasMediator public="1" set="method">
			<f a="mediatorName">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if a [Mediator] is registered or not</haxe_doc>
		</hasMediator>
		<removeMediator public="1" set="method">
			<f a="mediatorName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
			</f>
			<haxe_doc>* Remove a [IMediator] instance from the [View].</haxe_doc>
		</removeMediator>
		<retrieveMediator public="1" set="method">
			<f a="mediatorName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
			</f>
			<haxe_doc>* Retrieve an [IMediator] instance from the [View].</haxe_doc>
		</retrieveMediator>
		<registerMediator public="1" set="method">
			<f a="mediator">
				<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register an [IMediator] instance with the [View].</haxe_doc>
		</registerMediator>
		<hasCommand public="1" set="method">
			<f a="notificationName">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if a [Command] is registered for a given Notification</haxe_doc>
		</hasCommand>
		<removeCommand public="1" set="method">
			<f a="notificationName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove a previously registered [ICommand] to [INotification] mapping from the Controller.</haxe_doc>
		</removeCommand>
		<registerCommand public="1" set="method">
			<f a="noteName:commandClassRef">
				<c path="String"/>
				<x path="Class"><c path="org.puremvc.haxe.multicore.interfaces.ICommand"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register an [ICommand] with the [Controller].</haxe_doc>
		</registerCommand>
		<hasProxy public="1" set="method">
			<f a="proxyName">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if a [Proxy] is registered</haxe_doc>
		</hasProxy>
		<removeProxy public="1" set="method">
			<f a="proxyName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
			</f>
			<haxe_doc>* Remove an [IProxy] instance from the [Model] by name.</haxe_doc>
		</removeProxy>
		<retrieveProxy public="1" set="method">
			<f a="proxyName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
			</f>
			<haxe_doc>* Retrieve a [IProxy] from the [Model] by name.</haxe_doc>
		</retrieveProxy>
		<registerProxy public="1" set="method">
			<f a="proxy">
				<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register an [IProxy] with the [Model] by name.</haxe_doc>
		</registerProxy>
		<haxe_doc><![CDATA[* The interface definition for a PureMVC Facade.
 *
 * <p>The Facade Pattern suggests providing a single
 * class to act as a central point of communication 
 * for a subsystem.</p>
 * 
 * <p>In PureMVC, the Facade acts as an interface between
 * the core MVC actors (Model, View, Controller) and
 * the rest of your application.</p>]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.interfaces.IMediator" params="" file="src/org/puremvc/haxe/multicore/interfaces/IMediator.hx" interface="1">
		<extends path="org.puremvc.haxe.multicore.interfaces.INotifier"/>
		<onRemove public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the [View] when the [Mediator] is removed</haxe_doc>
		</onRemove>
		<onRegister public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the [View] when the [Mediator] is registered</haxe_doc>
		</onRegister>
		<handleNotification public="1" set="method">
			<f a="notification">
				<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Handle an [INotification].</haxe_doc>
		</handleNotification>
		<listNotificationInterests public="1" set="method">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>* List [INotification] interests.</haxe_doc>
		</listNotificationInterests>
		<setViewComponent public="1" set="method">
			<f a="viewComponent">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the [IMediator]'s view component.</haxe_doc>
		</setViewComponent>
		<getViewComponent public="1" set="method">
			<f a=""><d/></f>
			<haxe_doc>* Get the [IMediator]'s view component.</haxe_doc>
		</getViewComponent>
		<getMediatorName public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Get the [IMediator] instance name</haxe_doc>
		</getMediatorName>
		<haxe_doc><![CDATA[* The interface definition for a PureMVC Mediator.
 *
 * <p>In PureMVC, [IMediator] implementors assume these responsibilities:</p>
 * <ul>
 * <li>Implement a common method which returns a list of all [INotification]s 
 * the [IMediator] has interest in.</li>
 * <li>Implement a common notification (callback) method.</li>
 * </ul>
 * <p>Additionally, [IMediator]s typically:</p>
 * <ul>
 * <li>Act as an intermediary between one or more view components such as text boxes or 
 * list controls, maintaining references and coordinating their behavior.</li>
 * <li>In Flash-based apps, this is often the place where event listeners are
 * added to view components, and their handlers implemented.</li>
 * <li>Respond to and generate [INotifications], interacting with of 
 * the rest of the PureMVC app.</li>
 * </ul>
 * <p>When an [IMediator] is registered with the [IView], 
 * the [IView] will call the [IMediator]'s 
 * [listNotificationInterests] method. The [IMediator] will 
 * return an [Array] of [INotification] names which 
 * it wishes to be notified about.</p>
 * 
 * <p>The [IView] will then create an [Observer] object 
 * encapsulating that [IMediator]'s ([handleNotification]) method
 * and register it as an Observer for each [INotification] name returned by 
 * [listNotificationInterests].</p>]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.interfaces.INotification" params="" file="src/org/puremvc/haxe/multicore/interfaces/INotification.hx" interface="1">
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Get the string representation of the [INotification] instance</haxe_doc>
		</toString>
		<getType public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Get the type of the [INotification] instance</haxe_doc>
		</getType>
		<setType public="1" set="method">
			<f a="type">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the type of the [INotification] instance</haxe_doc>
		</setType>
		<getBody public="1" set="method">
			<f a=""><d/></f>
			<haxe_doc>* Get the body of the [INotification] instance</haxe_doc>
		</getBody>
		<setBody public="1" set="method">
			<f a="body">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the body of the [INotification] instance</haxe_doc>
		</setBody>
		<getName public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Get the name of the [INotification] instance. 
	 * No setter, should be set by constructor only</haxe_doc>
		</getName>
		<haxe_doc><![CDATA[* The interface definition for a PureMVC Notification.
 *
 * <p>PureMVC does not rely upon underlying event models such 
 * as the one provided with Flash.</p>
 * 
 * <p>The Observer Pattern as implemented within PureMVC exists 
 * to support event-driven communication between the 
 * application and the actors of the MVC triad.</p>
 * 
 * <p>Notifications are not meant to be a replacement for Events.
 * Generally, [IMediator] implementors
 * place event listeners on their view components, which they
 * then handle in the usual way. This may lead to the broadcast of [Notification]s to 
 * trigger [ICommand]s or to communicate with other [IMediators]. [IProxy] and [ICommand]
 * instances communicate with each other and [IMediator]s 
 * by broadcasting [INotification]s.</p>
 * 
 * <p>A key difference between Flash [Event]s and PureMVC 
 * [Notification]s is that [Event]s follow the 
 * 'Chain of Responsibility' pattern, 'bubbling' up the display hierarchy 
 * until some parent component handles the [Event], while
 * PureMVC [Notification]s follow a 'Publish/Subscribe'
 * pattern. PureMVC classes need not be related to each other in a 
 * parent/child relationship in order to communicate with one another
 * using [Notification]s.]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.interfaces.IObserver" params="" file="src/org/puremvc/haxe/multicore/interfaces/IObserver.hx" interface="1">
		<compareNotifyContext public="1" set="method">
			<f a="object">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Compare the given object to the notificaiton context object.</haxe_doc>
		</compareNotifyContext>
		<notifyObserver public="1" set="method">
			<f a="notification">
				<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Notify the interested object.</haxe_doc>
		</notifyObserver>
		<setNotifyContext public="1" set="method">
			<f a="notifyContext">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the notification context.</haxe_doc>
		</setNotifyContext>
		<setNotifyMethod public="1" set="method">
			<f a="notifyMethod">
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Set the notification method.
	 * 
	 * <p>The notification method should take one parameter of type [INotification]</p>]]></haxe_doc>
		</setNotifyMethod>
		<haxe_doc><![CDATA[* The interface definition for a PureMVC Observer.
 *
 * <p>In PureMVC, [IObserver] implementors assume these responsibilities:
 * <ul>
 * <li>Encapsulate the notification (callback) method of the interested object.</li>
 * <li>Encapsulate the notification context (this) of the interested object.</li>
 * <li>Provide methods for setting the interested object' notification method and context.</li>
 * <li>Provide a method for notifying the interested object.</li>
 * </ul>
 * 
 * <p>PureMVC does not rely upon underlying event
 * models such as the one provided with Flash.</p>
 * 
 * <p>The Observer Pattern as implemented within
 * PureMVC exists to support event driven communication
 * between the application and the actors of the MVC triad.</p>
 * 
 * <p> An Observer is an object that encapsulates information
 * about an interested object with a notification method that
 * should be called when an [INotification] is broadcast. The Observer then
 * acts as a proxy for notifying the interested object.
 * 
 * <p>Observers can receive [Notification]s by having their
 * [notifyObserver] method invoked, passing
 * in an object implementing the [INotification] interface, such
 * as a subclass of [Notification].</p>]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.interfaces.IProxy" params="" file="src/org/puremvc/haxe/multicore/interfaces/IProxy.hx" interface="1">
		<extends path="org.puremvc.haxe.multicore.interfaces.INotifier"/>
		<onRemove public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the Model when the [Proxy] is removed</haxe_doc>
		</onRemove>
		<onRegister public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the Model when the [Proxy] is registered</haxe_doc>
		</onRegister>
		<getData public="1" set="method">
			<f a=""><d/></f>
			<haxe_doc>* Get the data object</haxe_doc>
		</getData>
		<setData public="1" set="method">
			<f a="data">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the data object</haxe_doc>
		</setData>
		<getProxyName public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Get the [Proxy] name</haxe_doc>
		</getProxyName>
		<haxe_doc><![CDATA[* The interface definition for a PureMVC Proxy.
 *
 * <p>In PureMVC, [IProxy] implementors assume these responsibilities:</p>
 * <ul>
 * <li>Implement a common method which returns the name of the [Proxy].</li>
 * </ul>
 * <p>Additionally, [IProxy]s typically:</p>
 * <ul>
 * <li>Maintain references to one or more pieces of model data.</li>
 * <li>Provide methods for manipulating that data.</li>
 * <li>Generate [INotifications] when their model data changes.</li>
 * <li>Expose their name as a [public static var] called [NAME].</li>
 * <li>Encapsulate interaction with local or remote services used to fetch and persist model data.</li>
 * </ul>]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.patterns.observer.Notifier" params="" file="src/org/puremvc/haxe/multicore/patterns/observer/Notifier.hx">
		<implements path="org.puremvc.haxe.multicore.interfaces.INotifier"/>
		<MULTITON_MSG get="inline" set="null" line="89" static="1"><c path="String"/></MULTITON_MSG>
		<multitonKey><c path="String"/></multitonKey>
		<getFacade set="method" line="80"><f a=""><c path="org.puremvc.haxe.multicore.interfaces.IFacade"/></f></getFacade>
		<get_facade set="method" line="74"><f a=""><c path="org.puremvc.haxe.multicore.interfaces.IFacade"/></f></get_facade>
		<facade public="1" get="get_facade" set="null"><c path="org.puremvc.haxe.multicore.interfaces.IFacade"/></facade>
		<initializeNotifier public="1" set="method" line="62"><f a="key">
	<c path="String"/>
	<x path="Void"/>
</f></initializeNotifier>
		<sendNotification public="1" set="method" line="42"><f a="notificationName:?body:?type">
	<c path="String"/>
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></sendNotification>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* A Base [INotifier] implementation.
 * 
 * <p>[MacroCommand, Command, Mediator] and [Proxy] 
 * all have a need to send [Notifications].</p>
 *
 * <p>The [INotifier] interface provides a common method called
 * [sendNotification] that relieves implementation code of 
 * the necessity to actually construct [Notifications].</p>
 * 
 * <p>The [Notifier] class, which all of the above mentioned classes
 * extend, provides an initialized reference to the [Facade]
 * Singleton, which is required for the convienience method
 * for sending [Notifications], but also eases implementation as these
 * classes have frequent [Facade] interactions and usually require
 * access to the facade anyway.</p>]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.patterns.command.MacroCommand" params="" file="src/org/puremvc/haxe/multicore/patterns/command/MacroCommand.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.observer.Notifier"/>
		<implements path="org.puremvc.haxe.multicore.interfaces.ICommand"/>
		<execute public="1" set="method" line="89"><f a="notification">
	<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
	<x path="Void"/>
</f></execute>
		<addSubCommand set="method" line="78"><f a="commandClassRef">
	<x path="Class"><c path="org.puremvc.haxe.multicore.interfaces.ICommand"/></x>
	<x path="Void"/>
</f></addSubCommand>
		<initializeMacroCommand set="method" line="68"><f a=""><x path="Void"/></f></initializeMacroCommand>
		<subCommands><c path="List"><x path="Class"><c path="org.puremvc.haxe.multicore.interfaces.ICommand"/></x></c></subCommands>
		<new public="1" set="method" line="51">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Constructor. 
	 * 
	 * <p>You should not need to define a constructor, 
	 * instead, override the [initializeMacroCommand]
	 * method.</p>
	 * 
	 * <p>
	 * If your subclass does define a constructor, be 
	 * sure to call [super()].</p>]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A base [ICommand] implementation that executes other [ICommand]s.
 *  
 * <p>A [MacroCommand] maintains an list of
 * [ICommand] Class references called <em>SubCommands</em>.</p>
 * 
 * <p>When [execute] is called, the [MacroCommand] 
 * instantiates and calls [execute] on each of its <em>SubCommands</em> turn.
 * Each <em>SubCommand</em> will be passed a reference to the original
 * [INotification] that was passed to the [MacroCommand]'s 
 * [execute] method.</p>
 * 
 * <p>Unlike [SimpleCommand], your subclass
 * should not override [execute], but instead, should 
 * override the [initializeMacroCommand] method, 
 * calling [addSubCommand] once for each <em>SubCommand</em>
 * to be executed.</p>]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.patterns.command.SimpleCommand" params="" file="src/org/puremvc/haxe/multicore/patterns/command/SimpleCommand.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.observer.Notifier"/>
		<implements path="org.puremvc.haxe.multicore.interfaces.ICommand"/>
		<execute public="1" set="method" line="33">
			<f a="notification">
				<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Fulfill the use-case initiated by the given [INotification].
	 * 
	 * <p>In the Command Pattern, an application use-case typically
	 * begins with some user action, which results in an [INotification] being broadcast, which 
	 * is handled by business logic in the [execute] method of an [ICommand].</p>]]></haxe_doc>
		</execute>
		<new public="1" set="method" line="21"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* A base [ICommand] implementation.
 * 
 * <p>Your subclass should override the [execute] 
 * method where your business logic will handle the [INotification].</p>]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.patterns.facade.Facade" params="" file="src/org/puremvc/haxe/multicore/patterns/facade/Facade.hx">
		<implements path="org.puremvc.haxe.multicore.interfaces.IFacade"/>
		<getInstance public="1" set="method" line="64" static="1"><f a="key">
	<c path="String"/>
	<c path="org.puremvc.haxe.multicore.interfaces.IFacade"/>
</f></getInstance>
		<instanceMap static="1"><c path="haxe.ds.StringMap"><c path="org.puremvc.haxe.multicore.interfaces.IFacade"/></c></instanceMap>
		<multitonKey><c path="String"/></multitonKey>
		<view><c path="org.puremvc.haxe.multicore.interfaces.IView"/></view>
		<model><c path="org.puremvc.haxe.multicore.interfaces.IModel"/></model>
		<controller><c path="org.puremvc.haxe.multicore.interfaces.IController"/></controller>
		<removeCore public="1" set="method" line="268"><f a="key">
	<c path="String"/>
	<x path="Void"/>
</f></removeCore>
		<initializeNotifier public="1" set="method" line="260"><f a="key">
	<c path="String"/>
	<x path="Void"/>
</f></initializeNotifier>
		<notifyObservers public="1" set="method" line="247"><f a="notification">
	<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
	<x path="Void"/>
</f></notifyObservers>
		<sendNotification public="1" set="method" line="239"><f a="notificationName:?body:?type">
	<c path="String"/>
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></sendNotification>
		<hasMediator public="1" set="method" line="228"><f a="mediatorName">
	<c path="String"/>
	<x path="Bool"/>
</f></hasMediator>
		<removeMediator public="1" set="method" line="218"><f a="mediatorName">
	<c path="String"/>
	<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
</f></removeMediator>
		<retrieveMediator public="1" set="method" line="210"><f a="mediatorName">
	<c path="String"/>
	<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
</f></retrieveMediator>
		<registerMediator public="1" set="method" line="202"><f a="mediator">
	<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
	<x path="Void"/>
</f></registerMediator>
		<hasProxy public="1" set="method" line="194"><f a="proxyName">
	<c path="String"/>
	<x path="Bool"/>
</f></hasProxy>
		<removeProxy public="1" set="method" line="184"><f a="proxyName">
	<c path="String"/>
	<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
</f></removeProxy>
		<retrieveProxy public="1" set="method" line="176"><f a="proxyName">
	<c path="String"/>
	<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
</f></retrieveProxy>
		<registerProxy public="1" set="method" line="168"><f a="proxy">
	<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
	<x path="Void"/>
</f></registerProxy>
		<hasCommand public="1" set="method" line="160"><f a="notificationName">
	<c path="String"/>
	<x path="Bool"/>
</f></hasCommand>
		<removeCommand public="1" set="method" line="152"><f a="notificationName">
	<c path="String"/>
	<x path="Void"/>
</f></removeCommand>
		<registerCommand public="1" set="method" line="144"><f a="notificationName:commandClassRef">
	<c path="String"/>
	<x path="Class"><c path="org.puremvc.haxe.multicore.interfaces.ICommand"/></x>
	<x path="Void"/>
</f></registerCommand>
		<initializeView set="method" line="135"><f a=""><x path="Void"/></f></initializeView>
		<initializeModel set="method" line="111"><f a=""><x path="Void"/></f></initializeModel>
		<initializeController set="method" line="84"><f a=""><x path="Void"/></f></initializeController>
		<initializeFacade set="method" line="54"><f a=""><x path="Void"/></f></initializeFacade>
		<new set="method" line="40">
			<f a="key">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Constructor. 
	 * 
	 * <p>This [IFacade] implementation is a Multiton, so you should not call the constructor 
	 * directly, but instead call the static Factory method
	 * passing the unique key for this instance
	 * [Facade.getInstance( multitonKey )]</p>]]></haxe_doc>
		</new>
		<haxe_doc>* A base Multiton [IFacade] implementation.</haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.patterns.mediator.Mediator" params="" file="src/org/puremvc/haxe/multicore/patterns/mediator/Mediator.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.observer.Notifier"/>
		<implements path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
		<NAME public="1" line="30" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The name of the [Mediator]. 
	 * 
	 * <p>Typically, a [Mediator] will be written to serve
	 * one specific control or group controls and so,
	 * will not have a need to be dynamically named.</p>]]></haxe_doc>
		</NAME>
		<viewComponent><d/></viewComponent>
		<mediatorName><c path="String"/></mediatorName>
		<onRemove public="1" set="method" line="98"><f a=""><x path="Void"/></f></onRemove>
		<onRegister public="1" set="method" line="91"><f a=""><x path="Void"/></f></onRegister>
		<handleNotification public="1" set="method" line="83"><f a="notification">
	<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
	<x path="Void"/>
</f></handleNotification>
		<listNotificationInterests public="1" set="method" line="71"><f a=""><c path="Array"><c path="String"/></c></f></listNotificationInterests>
		<getViewComponent public="1" set="method" line="62"><f a=""><d/></f></getViewComponent>
		<setViewComponent public="1" set="method" line="54"><f a="viewComponent">
	<d/>
	<x path="Void"/>
</f></setViewComponent>
		<getMediatorName public="1" set="method" line="46"><f a=""><c path="String"/></f></getMediatorName>
		<new public="1" set="method" line="35">
			<f a="?mediatorName:?viewComponent">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor.</haxe_doc>
		</new>
		<haxe_doc>* A base [IMediator] implementation.</haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.patterns.observer.Notification" params="" file="src/org/puremvc/haxe/multicore/patterns/observer/Notification.hx">
		<implements path="org.puremvc.haxe.multicore.interfaces.INotification"/>
		<body><d/></body>
		<type><c path="String"/></type>
		<name><c path="String"/></name>
		<toString public="1" set="method" line="90"><f a=""><c path="String"/></f></toString>
		<getType public="1" set="method" line="82"><f a=""><c path="String"/></f></getType>
		<setType public="1" set="method" line="74"><f a="type">
	<c path="String"/>
	<x path="Void"/>
</f></setType>
		<getBody public="1" set="method" line="66"><f a=""><d/></f></getBody>
		<setBody public="1" set="method" line="58"><f a="body">
	<d/>
	<x path="Void"/>
</f></setBody>
		<getName public="1" set="method" line="50"><f a=""><c path="String"/></f></getName>
		<new public="1" set="method" line="40">
			<f a="name:?body:?type">
				<c path="String"/>
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A base [INotification] implementation.
 * 
 * <p>PureMVC does not rely upon underlying event models such 
 * as the one provided with Flash.</p>
 * 
 * <p>The Observer Pattern as implemented within PureMVC exists 
 * to support event-driven communication between the 
 * application and the actors of the MVC triad.</p>
 * 
 * <p>Notifications are not meant to be a replacement for Events.
 * Generally, [IMediator] implementors place event listeners on their view components, which they
 * then handle in the usual way. This may lead to the broadcast of [Notification]s to 
 * trigger [ICommand]s or to communicate with other [IMediators]. [IProxy] and [ICommand]
 * instances communicate with each other and [IMediator]s  by broadcasting [INotification]s.</p>
 * 
 * <p>A key difference between Flash [Event]s and PureMVC 
 * [Notification]s is that [Event]s follow the 
 * 'Chain of Responsibility' pattern, 'bubbling' up the display hierarchy 
 * until some parent component handles the [Event], while
 * PureMVC [Notification]s follow a 'Publish/Subscribe'
 * pattern. PureMVC classes need not be related to each other in a 
 * parent/child relationship in order to communicate with one another
 * using [Notification]s.]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.patterns.observer.Observer" params="" file="src/org/puremvc/haxe/multicore/patterns/observer/Observer.hx">
		<implements path="org.puremvc.haxe.multicore.interfaces.IObserver"/>
		<compareNotifyContext public="1" set="method" line="89"><f a="object">
	<d/>
	<x path="Bool"/>
</f></compareNotifyContext>
		<notifyObserver public="1" set="method" line="81"><f a="notification">
	<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
	<x path="Void"/>
</f></notifyObserver>
		<getNotifyContext set="method" line="73"><f a=""><d/></f></getNotifyContext>
		<getNotifyMethod set="method" line="65"><f a=""><f a="">
	<d/>
	<x path="Void"/>
</f></f></getNotifyMethod>
		<setNotifyContext public="1" set="method" line="57"><f a="notifyContext">
	<d/>
	<x path="Void"/>
</f></setNotifyContext>
		<setNotifyMethod public="1" set="method" line="49"><f a="notifyMethod">
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></setNotifyMethod>
		<context><d/></context>
		<notify><f a="">
	<d/>
	<x path="Void"/>
</f></notify>
		<new public="1" set="method" line="38">
			<f a="notifyMethod:notifyContext">
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Constructor. 
	 * 
	 * <p>The notification method on the interested object should take 
	 * one parameter of type [INotification]</p>]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A base [IObserver] implementation.
 * 
 * <p>An [Observer] is an object that encapsulates information
 * about an interested object with a method that should 
 * be called when a particular [INotification] is broadcast.</p>
 * 
 * <p>In PureMVC, the [Observer] class assumes these responsibilities:</p>
 * <ul>
 * <li>Encapsulate the notification (callback) method of the interested object.</li>
 * <li>Encapsulate the notification context (this) of the interested object.</li>
 * <li>Provide methods for setting the notification method and context.</li>
 * <li>Provide a method for notifying the interested object.</li>
 * </ul>]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.patterns.proxy.Proxy" params="" file="src/org/puremvc/haxe/multicore/patterns/proxy/Proxy.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.observer.Notifier"/>
		<implements path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
		<NAME public="1" line="35" static="1"><c path="String"/></NAME>
		<data><d/></data>
		<proxyName><c path="String"/></proxyName>
		<onRemove public="1" set="method" line="82"><f a=""><x path="Void"/></f></onRemove>
		<onRegister public="1" set="method" line="74"><f a=""><x path="Void"/></f></onRegister>
		<getData public="1" set="method" line="66"><f a=""><d/></f></getData>
		<setData public="1" set="method" line="58"><f a="data">
	<d/>
	<x path="Void"/>
</f></setData>
		<getProxyName public="1" set="method" line="50"><f a=""><c path="String"/></f></getProxyName>
		<new public="1" set="method" line="40">
			<f a="?proxyName:?data">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A base [IProxy] implementation. 
 * 
 * <p>In PureMVC, [Proxy] classes are used to manage parts of the 
 * application's data model. </p>
 * 
 * <p>A [Proxy] might simply manage a reference to a local data object, 
 * in which case interacting with it might involve setting and 
 * getting of its data in synchronous fashion.</p>
 * 
 * <p>[Proxy] classes are also used to encapsulate the application's 
 * interaction with remote services to save or retrieve data, in which case, 
 * we adopt an asyncronous idiom; setting data (or calling a method) on the 
 * [Proxy] and listening for a [Notification] to be sent 
 * when the [Proxy] has retrieved the data from the service.</p>]]></haxe_doc>
	</class>
</haxe>